# 三、参数传递、改变 this 指向

## 什么是按值传递呢？

- 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。

## 1、按值传递

```js
var value = 1;
function foo(v) {
  v = 2;
  console.log(v); //2
}
foo(value);
console.log(value); // 1
```

## 2、引用传递

```js
var obj = {
  value: 1
};
function foo(o) {
  o.value = 2;
  console.log(o.value); //2
}
foo(obj);
console.log(obj.value); // 2
```

## 3、第三种传递方式

```js
var obj = {
  value: 1
};
function foo(o) {
  o = 2;
  console.log(o); //2
}
foo(obj);
console.log(obj.value); // 1
```

- 总结: ECMAScript 中所有函数的参数都是按值传递的。例子 3 中 foo(obj) 这里执行的时候， 形参部分相当于 o = obj ; o = 2,相当于 o 重新赋值 2,也符合值传递的理解

## 改变 this 指向

### 1. call、apply 和 bind 函数存在的区别:

- call 方法第一个参数是要绑定给 this 的值，后面传入的是一个参数列表。当第一个参数为 null、undefined 的时候，默认指向 window

- apply 接受两个参数，第一个参数是要绑定给 this 的值，第二个参数是一个参数数组。当第一个参数为 null、undefined 的时候，默认指向 window。

- 和 call 很相似，第一个参数是 this 的指向，从第二个参数开始是接收的参数列表。区别在于 bind 方法返回值是函数以及 bind 接收的参数列表的使用。

```js
// 接收参数列表的使用
function fn(a, b, c) {
  console.log(a, b, c);
}
var fn1 = fn.bind(null, 'Dot');

fn('A', 'B', 'C'); // A B C
fn1('A', 'B', 'C'); // Dot A B
fn1('B', 'C'); // Dot B C
fn.call(null, 'Dot'); // Dot undefined undefined
```

### 2. call 的应用场景

```js
// 将类数组转化为数组
var trueArr = Array.prototype.slice.call(arrayLike);

// 判断变量类型
function isArray(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
}
isArray([]); // true
isArray('dot'); // false

// 利用call和apply做继承
function Person(name, age) {
  // 这里的this都指向实例
  this.name = name;
  this.age = age;
  this.sayAge = function() {
    console.log(this.age);
  };
}
function Female() {
  Person.apply(this, arguments); //将父元素所有方法在这里执行一遍就继承了
}
var dot = new Female('Dot', 2);
```

### 注意:

- bind 返回对应函数, 便于稍后调用； apply, call 则是立即调用。
- 除此外, 在 ES6 的箭头函数下, call 和 apply 将失效, 对于箭头函数来说:
  箭头函数体内的 this 对象, 就是定义时所在的对象, 而不是使用时所在的对象;所以不需要类似于 var \_this = this 这种丑陋的写法
- 箭头函数不可以当作构造函数，也就是说不可以使用 new 命令, 否则会抛出一个错误
- 箭头函数不可以使用 arguments 对象,该对象在函数体内不存在. 如果要用, 可以用 Rest 参数代替

### 拓展

```js
var arrayLike = { 0: 'name', 1: 'age', 2: 'sex', length: 3 };
// 1. slice
Array.prototype.slice.call(arrayLike); // ["name", "age", "sex"]
// 2. splice
Array.prototype.splice.call(arrayLike, 0); // ["name", "age", "sex"]
// 3. ES6 Array.from
Array.from(arrayLike); // ["name", "age", "sex"]
// 4. apply
Array.prototype.concat.apply([], arrayLike);
```
