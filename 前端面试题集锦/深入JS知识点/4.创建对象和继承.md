# 四、构建对象和继承的多种方式

## 一、构建对象的多种方式

### 1、工厂模式

```js
function createPerson(name) {
  var o = new Object();
  o.name = name;
  o.getName = function() {
    console.log(this.name);
  };

  return o;
}

var person1 = createPerson('kevin');
```

- 缺点: 对象无法识别，因为所有的实例都指向一个原型

### 2、构造函数模式

```js
function Person(name) {
  this.name = name;
  this.getName = function() {
    console.log(this.name);
  };
}

var person1 = new Person('kevin');
```

- 优点:实例可以识别为一个特定的类型
- 缺点:每次创建实例时，每个方法都要被创建一次

### 3、原型模式

```js
function Person(name) {}

Person.prototype.name = 'keivn';
Person.prototype.getName = function() {
  console.log(this.name);
};

var person1 = new Person();
```

- 优点:方法不会重新创建
- 缺点:1. 所有的属性和方法都共享 2. 不能初始化参数

### 4、组合模式

- 构造函数模式与原型模式双剑合璧。

```js
function Person(name) {
  this.name = name;
}

Person.prototype = {
  constructor: Person,
  getName: function() {
    console.log(this.name);
  }
};

var person1 = new Person();
```

- 优点:该共享的共享，该私有的私有，使用最广泛的方式
- 缺点:

### 5.1、寄生-构造函数模式

```js
function Person(name) {
  var o = new Object();
  o.name = name;
  o.getName = function() {
    console.log(this.name);
  };

  return o;
}

var person1 = new Person('kevin');
console.log(person1 instanceof Person); // false
console.log(person1 instanceof Object); // true
```

- 缺点:

```js
```

- 缺点:

## 二、继承的多种方式

### 1. 原型链继承

```js
function Parent() {
  this.name = 'kevin';
}

Parent.prototype.getName = function() {
  console.log(this.name);
};

function Child() {}

Child.prototype = new Parent();

var child1 = new Child();

console.log(child1.getName()); // kevin
```

- 特点:

  - 引用类型的属性被所有实例共享;
  - 在创建 Child 的实例时，不能向 Parent 传参

### 2. 借用构造函数(经典继承)

```js
function Parent() {
  this.names = ['kevin', 'daisy'];
}

function Child() {
  Parent.call(this);
}

var child1 = new Child();

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy"]
```

- 优点：

  - 避免了引用类型的属性被所有实例共享

  - 可以在 Child 中向 Parent 传参

- 缺点：

  - 方法都在构造函数中定义，每次创建实例都会创建一遍方法。

### 3. 组合继承

原型链继承和经典继承双剑合璧。

```js
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function() {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name);

  this.age = age;
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child1 = new Child('kevin', '18');

child1.colors.push('black');

console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

var child2 = new Child('daisy', '20');

console.log(child2.name); // daisy
console.log(child2.age); // 20
console.log(child2.colors); // ["red", "blue", "green"]
```

- 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。

### 4. 原型式继承

```js
function createObj(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
```

缺点: 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。

### 5. 寄生式继承

创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。

```js
function createObj(o) {
  var clone = Object.create(o);
  clone.sayName = function() {
    console.log('hi');
  };
  return clone;
}
```

缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。

### 6. 寄生组合式继承

```js
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

function prototype(child, parent) {
  var prototype = object(parent.prototype);
  prototype.constructor = child;
  child.prototype = prototype;
}

// 当我们使用的时候：
prototype(Child, Parent);
```

- 优点:这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变,是引用类型最理想的继承范式
