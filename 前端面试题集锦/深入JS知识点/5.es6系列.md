## ES6 系列

### 1、模板字符串链接:

https://github.com/mqyqingfeng/Blog/issues/84

### 2、箭头函数链接:

https://github.com/mqyqingfeng/Blog/issues/85

### 3、模拟实现 symbol 链接:

https://github.com/mqyqingfeng/Blog/issues/87

### 4、for...of 链接:

https://github.com/mqyqingfeng/Blog/issues/90

- for...of 与 for...in 对比

1. 推荐在循环对象属性的时候，使用 for...in, 在遍历数组的时候的时候使用 for...of。

2. for...in 循环出的是 key，for...of 循环出的是 value

   - 注意，for...of 是 ES6 新引入的特性。修复了 ES5 引入的 for...in 的不足

3. for...of 不能循环普通的对象，需要通过和 Object.keys()搭配使用

### 举个 🌰:

假设我们要遍历一个数组的 value, let aArray = ['a',123,{a:'1',b:'2'}]

使用 for...in 循环：

```js
for (let index in aArray) {
  console.log(`${aArray[index]}`);
}
```

使用 for...of 循环：

```js
for (let value of aArray) {
  console.log(value);
}
```

for...of 循环不会循环对象的 key，只会循环出数组的 value，因此 for...of 不能循环遍历普通对象,对普通对象的属性遍历推荐使用 for...in

如果实在想用 for...of 来遍历普通对象的属性的话，可以通过和 Object.keys()搭配使用，先获取对象的所有 key 的数组

然后遍历：

```js
var student = {
  name: 'wujunchuan',
  age: 22,
  locate: {
    country: 'china',
    city: 'xiamen',
    school: 'XMUT'
  }
};
for (var key of Object.keys(student)) {
  //使用Object.keys()方法获取对象key的数组
  console.log(key + ': ' + student[key]);
}
```

### 5、模拟实现 Set 数据结构链接:

https://github.com/mqyqingfeng/Blog/issues/91

### 6、Promise 链接:

https://github.com/mqyqingfeng/Blog/issues/98

### 红绿灯问题

题目：红灯三秒亮一次，绿灯一秒亮一次，黄灯 2 秒亮一次；如何让三个灯不断交替重复亮灯？（用 Promse 实现）

三个亮灯函数已经存在：

```js
function red() {
  console.log('red');
}
function green() {
  console.log('green');
}
function yellow() {
  console.log('yellow');
}
```

利用 then 和递归实现：

```js
function red() {
  console.log('red');
}
function green() {
  console.log('green');
}
function yellow() {
  console.log('yellow');
}

function light(times, cb) {
  return new Promise(function(resolve, reject) {
    setTimeOut(function() {
      cb();
      resolve();
    }, times);
  });
}

function step() {
  Promise.resolve()
    .then(function() {
      return light(3000, red);
    })
    .then(function() {
      return light(2000, green);
    })
    .then(function() {
      return light(1000, yellow);
    });
}
```

### 7、AMD、CMD 模块化 链接:

https://github.com/mqyqingfeng/Blog/issues/108

### 定义

- AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。

你去看 AMD 规范 的内容，其主要内容就是定义了 define 函数该如何书写，只要你按照这个规范书写模块和依赖，require.js 就能正确的进行解析。

- 与 AMD 一样，CMD 其实就是 SeaJS 在推广过程中对模块定义的规范化产出。

你去看 CMD 规范的内容，主要内容就是描述该如何定义模块，如何引入模块，如何导出模块，只要你按照这个规范书写代码，sea.js 就能正确的进行解析。

### 区别:

1. CMD 推崇依赖就近，AMD 推崇依赖前置。

2. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。

3. AMD 是将需要使用的模块先全部加载完再执行代码，而 CMD 是在 require 的时候才去加载模块文件，加载完就去执行,然后再加载下一个模块文件。

## CommonJS

- AMD 和 CMD 都是用于浏览器端的模块规范，而在服务器端比如 node，采用的则是 CommonJS 规范。

- CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。
  AMD 规范则是非同步加载模块，允许指定回调函数。

- 由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。
  但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。

### ES6 与 CommonJS

它们有两个重大差异:

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

第一个差异的原因:

- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

第二个差异的原因:

- 因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

### 7、装饰器 链接:

https://github.com/mqyqingfeng/Blog/issues/109

### 8、关于 Promise 和 setTimeout

https://www.cnblogs.com/sunmarvell/p/9564815.html


反向代理
