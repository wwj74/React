# 一、执行上下文

## 1、认识执行上下文

1. 当 js 执行到一个函数时,就会进行‘准备工作‘,即执行上下文
2. 运行规则:当执行一个函数时,就会创建一个执行上下文,并且 push 到上下文栈中;当函数执行完,就会从栈中 pop 出去;
3. 示例:

```js
function fun3() {
  console.log('fun3');
}

function fun2() {
  fun3();
}

function fun1() {
  fun2();
}

fun1();
```

4. 解析:
   上下文栈(Execution context stack)用 ECStack 数组表示.

```ts
// 伪代码

// fun1()  当js执行fun1函数时,会push到上下文栈中;
ECStack.push(<fun1>functionContext);

// fun1中竟然调用了fun2，还要创建fun2的执行上下文
ECStack.push(<fun2>functionContext);

// 擦，fun2还调用了fun3！
ECStack.push(<fun3>functionContext);

// fun3执行完毕
ECStack.pop();

// fun2执行完毕
ECStack.pop();

// fun1执行完毕
ECStack.pop();
```

5. 每个执行上下文,包含三个重要属性:

- 变量对象(Variabe Object)
- 作用域(Scope chain)
- this

---

## 2、执行上下文之变量对象

### 2.1 全局上下文

在 js 中,全局对象就是 window 对象.如:

```js
var a = 1;
console.log(window.a, this.a, this.window.a); //1 1 1
```

### 2.2 函数上下文

- 注意:函数上下文的变量对象初始化只包括 Arguments 对象

### 执行过程 : 执行上下文的执行过程分两个阶段:分析(进入执行上下文)和执行(代码执行)

1. 进入执行上下文(即变量提升)

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;
}

foo(1);
```

- 解析:
  进入执行上下文后,进行变量提升,此时:

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```

2. 代码执行
   当上面的例子执行完之后,变量如下变化:

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}

```

- 练习

```js
/* 第一题 */
function foo() {
  console.log(a);
  a = 1;
}
// 注意:此时并不是报undefined,而是报错 Uncaught ReferenceError: a is not defined

/* 第二题 */
console.log(foo);
function foo() {
  console.log('foo');
}

var foo = 1;
// 注意: 执行完上下文,打印的是函数,而不是undefined.
// 这是因为在执行上下文中,优先会处理函数声明,再处理变量声明;如果变量声明和函数声明命名相同,则会保留函数声明的值
```

---

## 3、执行上下文之作用域链

- 定义:当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。
  注意:词法作用域是在定义时就确定了的,而作用域链是根据运行时调用栈而定的

---

## 4、this

- 前提知识:ES5(ECMAScript5)类型分为语言类型和规范类型, 语言类型就是我们常用的 Undefined、Null、Boolean、String、Number、Object ; 规范类型其中有一个叫做 Reference 类型,引用尤雨溪大大的话:
  > Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”

### 4.1 Reference 的构成，由三个组成部分，分别是：

1. base value
2. referenced name
3. strict reference

- 举个 🌰 :

```js
var foo = 1;

// 对应的Reference是：
var fooReference = {
  base: EnvironmentRecord,
  name: 'foo',
  strict: false
};
```

### 4.2 规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。

- GetValue 返回对象属性真正的值，但是要重点注意：
  **调用 GetValue，返回的将是具体的值，而不再是一个 Reference**
- IsPropertyReference 如果 base value 是一个对象，就返回 true

### 判断 this 指向

1. 找到是谁调用(MemberExpression) 示例:

```js
function foo() {
  console.log(this);
}

foo(); // MemberExpression 是 foo

function foo() {
  return function() {
    console.log(this);
  };
}

foo()(); // MemberExpression 是 foo()

var foo = {
  bar: function() {
    return this;
  }
};

foo.bar(); // MemberExpression 是 foo.bar

//其实简单理解 MemberExpression 其实就是()左边的部分。
```

2. 判断 ref 是不是一个 Reference 类型。
   关键就在于看规范是如何处理各种 MemberExpression，返回的结果是不是一个 Reference 类型(语言类型)。

实战:

```js
var value = 1;

var foo = {
  value: 2,
  bar: function() {
    return this.value;
  }
};

//示例1
console.log(foo.bar());
//示例2
console.log(foo.bar());
//示例3
console.log((foo.bar = foo.bar)());
//示例4
console.log((false || foo.bar)());
//示例5
console.log((foo.bar, foo.bar)());
```

### foo.bar()

```js
var Reference = {
  base: foo,
  name: 'bar',
  strict: false
};

/*
 * 第一步,找到 MemberExpression,是 foo.bar,是 Reference
 * 第二步,base value 为 foo，是一个对象;执行 IsPropertyReference(ref),为 true;
 * 第三步, base value 值，这个例子中就是 foo,所以 this 的值就是 foo ，示例 1 的结果就是 2！
 */
```

### (foo.bar)()

```js
var Reference = {
  base: foo,
  name: 'bar',
  strict: false
};

/*
 * 第一步,找到 MemberExpression,是 foo.bar,是 Reference
 * 第二步,base value 为 foo，是一个对象;执行 IsPropertyReference(ref),为 true;
 * 第三步, base value 值，这个例子中就是 foo,所以 this 的值就是 foo ，示例 2 的结果就是 2！
 */
```

### (foo.bar = foo.bar)()

```js
var Reference = {
  base: foo,
  name: 'bar',
  strict: false
};

/*
 * 第一步,找到 MemberExpression,有赋值操作符 = ,也就是使用了GetValue，所以返回的值不是 Reference 类型
 * 第二步,如果 ref 不是Reference，那么 this 的值为 undefined
 * 第三步,this 为 undefined，非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象,也就是window对象。严格模式下就是undefined
 */
```

### (false || foo.bar)()

```js
// 逻辑与算法,使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined
```

### (foo.bar, foo.bar)()

```js
// 逗号操作符,使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined
```

最后结果:

```js
var value = 1;

var foo = {
  value: 2,
  bar: function() {
    return this.value;
  }
};

//示例1
console.log(foo.bar()); // 2
//示例2
console.log(foo.bar()); // 2
//示例3
console.log((foo.bar = foo.bar)()); // 1
//示例4
console.log((false || foo.bar)()); // 1
//示例5
console.log((foo.bar, foo.bar)()); // 1
```

注意：以上是在非严格模式下的结果，严格模式下因为 this 返回 undefined，所以示例 3 会报错。
