# 二、闭包

## 1、认识闭包

### 1.1 理论上的闭包

- 闭包是指那些能够访问自由变量的函数
- 自由变量是指在函数中使用的,但既不是函数参数也不是函数中定义的局部变量
- 结论:闭包 = 函数 + 函数能访问的自由变量

```js
举个🌰 :
let a=1;
function foo (){
  console.log(a)
}
foo();

foo 可以访问变量a,但是a既不是foo函数的参数,也不是foo函数的局部变量,所以a就是自由变量,函数foo+函数foo能够访问的变量a就构成了一个闭包
```

### 1.2 实践上的闭包

- 即使销毁了创建它的上下文,他依然存在
- 在代码中引用了自由变量

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope();
foo();

//结果:"local scope"

解析:
  1.进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
  2.全局执行上下文初始化
  3.执行 checkscope 函数，创建 checkscope 函数执行上下文，4.checkscope 执行上下文被压入执行上下文栈
  5.checkscope 执行上下文初始化，创建变量对象、作用域链、this等
  6.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
  7.执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
  8.f 执行上下文初始化，创建变量对象、作用域链、this等
  9.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

背景:词法作用域是在定义时就确定了的,而作用域链是根据运行时调用栈而定的
正是由于f函数在执行上下文时维护了一个作用域链,
fContext = {
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
}
所以即使checkscope弹出,依然能通过作用域链找到scope的值
```

### 1.3 必刷题

- 基础题

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function() {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();

// 结果:都是3

解析:由于运行data[i]的时候,i循环已经结束了,也就是说此时i=3,所以结果都是3;
执行data[0]时,
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
data[0]Context = {
    Scope: [AO, globalContext.VO]
}
data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。data[1] 和 data[2] 是一样的道理
```

- 变形题

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
        return function(){
            console.log(i);
        }
  })(i);
}

data[0]();
data[1]();
data[2]();
// 结果:0,1,2

解析:执行data[0]时,
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
跟之前一样

当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：

data[0]Context = {
    Scope: [AO, 匿名函数Context.AO globalContext.VO]
}

匿名函数Context = {
    AO: {
        arguments: {
            0: 0,
            length: 1
        },
        i: 0
    }
}
此时data[0]Context 的 AO 并没有 i 值,所以会从匿名函数Context中找到i的值,也就是0;同理可得data[1],data[2]的结果
```

- ⭐️ 延伸题

```js
var fn = null;
function foo() {
    var a = 2;
    function innnerFoo() {
        console.log(c);
        console.log(a);
    }
    fn = innnerFoo;
}

function bar() {
    var c = 100;
    fn();
}

foo();
bar();
错解:100,2
// 结果: Uncaught ReferenceError: c is not defined

解析:
背景:词法作用域是在定义时就确定了的,而作用域链是根据运行时调用栈而定的
在执行foo函数时,a和c的词法作用域都是定义于foo函数中,运行bar函数时,c的词法作用域依然指向foo函数,但是foo函数没有定义变量c,所以会报错


var fn = null;
function foo() {
    var a = 2;
    function innnerFoo() {
        console.log(c);
        console.log(a);
    }
    fn = innnerFoo;
}

foo();
// 结果:undefined
解析:
背景:undefined并不是程序报错，而是程序允许的一个值
    not defined是javascript在运行我们的javascript代码时，遇到没有定义就用来运算的变量时爆出来的错误
    在上面题目中,函数foo中没有定义变量c,所以会报undefined
```

### 拓展

```js
// Arguments 对象的 callee 属性，通过它可以调用函数自身。
var data = [];

for (var i = 0; i < 3; i++) {
  (data[i] = function() {
    console.log(arguments.callee.i);
  }).i = i;
}

data[0]();
data[1]();
data[2]();

// 0
// 1
// 2
```
