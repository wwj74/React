1. 为什么需要虚拟 DOM?

   浏览器内核拿到 html 文件后，大致分为一下 5 个步骤：

   <!-- 1. 浏览器获取 HTML 文件，然后对文件进行解析，形成 DOM Tree
   2. 与此同时，进行 CSS 解析，生成 Style Rules
   3. 接着将 DOM Tree 与 Style Rules 合成为 Render Tree
   4. 接着进入布局（Layout）阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标
   5. 随后调用 GPU 进行绘制（Paint），遍历 Render Tree 的节点，并将元素呈现出来 -->

   1. 解析 HTML，生成 DOM 树
   1. 解析 CSS，生成 CSSOM 树
   1. 将 DOM 树和 CSSOM 树结合，生成渲染树(Render Tree)
      Layout(回流)：根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
   1. Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素
   1. Display：将像素发送给 GPU，展示在页面上。

当你用原生 js 或 jquery 等库去操作 DOM 时，浏览器会从构建 DOM 树开始讲整个流程执行一遍，所以频繁操作 DOM 会引起不需要的计算，导致页面卡顿，影响用户体验。而 Virtual DOM 能很好的解决这个问题。它用 javascript 对象表示 virtual node(VNode 虚拟节点)，根据 VNode 计算出真实 DOM 需要做的最小变动，然后再操作真实 DOM 节点，提高渲染效率。

### 如何避免触发回流和重绘

CSS：

- 避免使用 table 布局。
- 尽可能在 DOM 树的最末端改变 class。
- 避免设置多层内联样式。
- 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上
- 避免使用 CSS 表达式（例如：calc()）
- CSS3 硬件加速（GPU 加速）

JavaScript：

- 避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性
- 避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有- DOM 操作，最后再把它添加到文档中
- 也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变- 缓存起来
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及- 续元素频繁回流

2. Virtual DOM

高效的 diff 算法能够保证进行对实际的 DOM 进行最小的变动。
React 里结合 Web 界面的特点做出了两个简单的假设，使得 Diff 算法复杂度直接降低到 O(n)。

1. 两个相同组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构；

2. 对于同一层次的一组子节点，它们可以通过唯一的 id 进行区分。

算法上的优化是 React 整个界面 Render 的基础，保证了整体界面渲染的性能。
React 的 DOM Diff 算法实际上只会对树进行逐层比较，两棵树只会对同一层次的节点进行比较如下所述。
React 只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

相同类型节点的比较

React 会对属性进行重设从而实现节点的转换。

地址: https://www.cxymsg.com/guide/virtualDom.html#%E4%BB%80%E4%B9%88%E6%98%AFvirtual-dom
